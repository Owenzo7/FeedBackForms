# Summary.

A liquid ETH staking derivative designed to uniquely leverage the Frax Finance ecosystem.

### Findings.

### [H-1](https://github.com/code-423n4/2022-09-frax-findings/issues/15) Wrong accounting logic when syncRewards() is called within beforewithdraw makes withdrawals impossible.

The `sfrx.beforewithdraw` first calls the `beforeWithdraw` of `xERC4626`, which decrements `storedTotalAssets` by the given amount.
When,
`(block.timestamp >= rewardsCycleEnd)`, `syncRewards` is called. However, the problem is that the assets have not been transferred out yet, meaning `asset.balanceOf(address(this))` still has the old value. On the other hand, **`storedTotalAssets`** was already updated. Therefore, the following calculation will be inflated by the amount for which the withdrawal was requested:

```solidity
uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;
```

This has severe consequences:
1.) During the following reward period, lastRewardAmount is too high, which means that too much rewards are paid out too users who want to withdraw. A user could exploit this to steal the assets of other users.
2.) When `syncRewards()` is called the next time, it is possible that the nextRewards calculation underflows because `lastRewardAmount > asset.balanceOf(address(this))`. This is very bad because `syncRewards()` will be called in every withdrawal (after the rewardsCycleEnd) and none of them will succeed because of the underflow. Depositing more also does not help here, it just increases asset.balanceOf(address(this)) and storedTotalAssets by the same amount, which does not eliminate the underflow.

## What went wrong and how to fix it next time.
* Didn`t think about this edge-case.
* Again didnt review the whole codebase.

## Take aways.

* When withdrawing from a vault contract take a keen look on what is going on with the variables that are responsible for the withdraw method i.e check for instances of overflows and underflows and make sure their updates are in sync with each other. (Would consider using fuzz).


### [H-2](https://github.com/code-423n4/2022-09-frax-findings/issues/81) Frontrunning by malicious validator.

Frontrunning by malicious validator changing withdrawal credentials.

A malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction

## What went wrong and how to fix it next time.
* Didn`t think Of this to be honest.

# Take aways.

* When dealing with liquid staking protocols, always check to see whether a malicious validator can frontrun a tx involving another innocent validator staking ETH and able to deposit ether by changing withdrawal credentials.

### [M-1] (https://github.com/code-423n4/2022-09-frax-findings/issues/107) Centralization risk: admin have privileges: admin can set address to mint any amount of frxETH, can set any address as validator, and change important state in frxETHMinter and withdraw fund from frcETHMinter.

`admin` have privileges: `admin` can set address to mint any amount of frxETH, can set any address as `validator`, and change important state in `frxETHMinter` and withdraw fund from `frcETHMinter`

note the modifier below, either the `timelock governance contract` or the `contract owner` can access to all the high privilege function.


```solidity

    modifier onlyByOwnGov() {
        require(msg.sender == timelock_address || msg.sender == owner, "Not owner or timelock");
        _;
    }
```

There are numerous methods that the `admin` could apply to rug pull the protocol and take all `user` funds.

the admin can;

1. add or remove validator from OperatorRegistry.sol

2. set minter address or remove minter address in frxETH.sol

3. minter set by admin can mint or burn any amount of frxETH token.

4. set ETE deduction ratio, withdraw any amount of ETH or ERC20 token in frcETHMinter.sol

## What went wrong and how to fix it next time.
* Didn`t think Of this to be honest.

# Take aways.

* Mitigation of this issue -> Without significant redesign it is not possible to avoid the admin being able to rug pull the protocol.

As a result the recommendation is to set all `admin` functions behind either a `timelocked DAO` or at least a `timelocked multisig contract`.

### [M-2] (https://github.com/code-423n4/2022-09-frax-findings/issues/110) Rewards delay release could cause yields steal and loss.

In the current rewards accounting, vault shares in `deposit()` and `redeem()` can not correctly record the spot yields generated by the staked asset. Yields are released over the next rewards cycle. As a result, `malicious users` can steal yields from `innocent users` by picking special timing to `deposit()` and `redeem()`.

In `syncRewards()`, the current asset balance is break into 2 parts: `storedTotalAssets` and `lastRewardAmount/nextRewards`. The lastRewardAmount is the surplus balance of the asset, or the most recent yields.

```solidity
// lib/ERC4626/src/xERC4626.sol
    function syncRewards() public virtual {
        // ...

        uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;

        storedTotalAssets = storedTotalAssets_ + lastRewardAmount_;

        uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;

        lastRewardAmount = nextRewards.safeCastTo192();
        // ...        
        rewardsCycleEnd = end;
    }

```

And in the next rewards cycle, `lastRewardAmount` will be linearly added to storedTotalAssets, their sum is the return value of totalAssets():



```solidity

    function totalAssets() public view override returns (uint256) {
        // ...

        if (block.timestamp >= rewardsCycleEnd_) {
            // no rewards or rewards fully unlocked
            // entire reward amount is available
            return storedTotalAssets_ + lastRewardAmount_;
        }

        // rewards not fully unlocked
        // add unlocked rewards to stored total
        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);
        return storedTotalAssets_ + unlockedRewards;
    }
```


`totalAssets()` will be referred when `deposit()` and `redeem()`.



```solidity

// lib/solmate/src/mixins/ERC4626.sol

    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {
        require((shares = previewDeposit(assets)) != 0, "ZERO_SHARES");
        // ...
        _mint(receiver, shares);
        // ...
    }

    function redeem() public virtual returns (uint256 assets) {
        // ...
        require((assets = previewRedeem(shares)) != 0, "ZERO_ASSETS");

        beforeWithdraw(assets, shares);

        _burn(owner, shares);

        // ...

        asset.safeTransfer(receiver, assets);
    }

    function previewDeposit(uint256 assets) public view virtual returns (uint256) {
        return convertToShares(assets);
    }

    function previewRedeem(uint256 shares) public view virtual returns (uint256) {
        return convertToAssets(shares);
    }

    function convertToShares(uint256 assets) public view virtual returns (uint256) {
        uint256 supply = totalSupply; 

        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());
    }

    function convertToAssets(uint256 shares) public view virtual returns (uint256) {
        uint256 supply = totalSupply; 

        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);
    }


```

 Based on the above rules, there are 2 potential abuse cases:

1. If `withdraw` just after the `rewardsCycleEnd timestamp`, a `user` can not get the yields from last rewards cycle. Since the `totalAssets()` only contain `storedTotalAssets` but not the yields part. It takes 1 rewards cycle to linearly add to the `storedTotalAssets`.

Assume per 10,000 asset staking generate yields of 70 for 7 days, and the reward cycle is 1 day. A malicious user Alice can do the following:

* watch the mempool for `withdraw(10,000)` from account Bob, front run it with `syncRewards()`, so that the most recent yields of amount 70 from Bob will stay in the vault.
* Alice will also deposit a 10,000 to take as much shares as possible.
* after 1 rewards cycle of 1 day, `redeem()` to take the yields of 70.

Effectively steal the yields from `Bob`. The profit for Alice is not 70, because after 1 day, her own deposit also generates some yield, in this example this portion is 1. At the end, Alice steal yield of `amount 60`.

2. When the `Multisig Treasury` transfers new yields into the vault, the new yields will accumulate until `syncRewards()` is called. It is possible that yields from multiple rewards cycles accumulates, and being released in the next cycle.

Knowing that the yields has been accumulated for 3 rewards cycles, a `malicious user` can `deposit()` and call `syncRewards()` to trigger the release of the rewards. `redeem()` after 1 cycle.

Here the malicious user gets yields of 3 cycles, lose 1 in the waiting cycle. The net profit is 2 cycle yields, and the gained yields should belong to the other `users` in the vault.


## What went wrong and how to fix it next time.
* Didn`t think Of this to be honest.


# Take aways.

* When dealing with rewards distribution when any delays have been used like cycles being compared with present time(`block.timestamp`) look for ways in which a malicious user can frontrun any tx that includes innocent users withdrawing their staked yields and see whether you can grief them with less or no yields.
* Mitigation of this issue -> or the `lastRewardAmount` not released, allow the users to redeem as it is linearly released later.

