# Summary.

A liquid ETH staking derivative designed to uniquely leverage the Frax Finance ecosystem.

### Findings.

### [H-1](https://github.com/code-423n4/2022-09-frax-findings/issues/15) Wrong accounting logic when syncRewards() is called within beforewithdraw makes withdrawals impossible.

The `sfrx.beforewithdraw` first calls the `beforeWithdraw` of `xERC4626`, which decrements `storedTotalAssets` by the given amount.
When,
`(block.timestamp >= rewardsCycleEnd)`, `syncRewards` is called. However, the problem is that the assets have not been transferred out yet, meaning `asset.balanceOf(address(this))` still has the old value. On the other hand, **`storedTotalAssets`** was already updated. Therefore, the following calculation will be inflated by the amount for which the withdrawal was requested:

```solidity
uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;
```

This has severe consequences:
1.) During the following reward period, lastRewardAmount is too high, which means that too much rewards are paid out too users who want to withdraw. A user could exploit this to steal the assets of other users.
2.) When `syncRewards()` is called the next time, it is possible that the nextRewards calculation underflows because `lastRewardAmount > asset.balanceOf(address(this))`. This is very bad because `syncRewards()` will be called in every withdrawal (after the rewardsCycleEnd) and none of them will succeed because of the underflow. Depositing more also does not help here, it just increases asset.balanceOf(address(this)) and storedTotalAssets by the same amount, which does not eliminate the underflow.

## What went wrong and how to fix it next time.
* Didn`t think about this edge-case.
* Again didnt review the whole codebase.

## Take aways.

* When withdrawing from a vault contract take a keen look on what is going on with the variables that are responsible for the withdraw method i.e check for instances of overflows and underflows and make sure their updates are in sync with each other. (Would consider using fuzz).


### [H-2](https://github.com/code-423n4/2022-09-frax-findings/issues/81) Frontrunning by malicious validator.

Frontrunning by malicious validator changing withdrawal credentials.

A malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction

## What went wrong and how to fix it next time.
* Didn`t think Of this to be honest.

# Take aways.

* When dealing with liquid staking protocols, always check to see whether a malicious validator can frontrun a tx involving another innocent validator staking ETH and able to deposit ether by changing withdrawal credentials.

### [M-1] (https://github.com/code-423n4/2022-09-frax-findings/issues/107) Centralization risk: admin have privileges: admin can set address to mint any amount of frxETH, can set any address as validator, and change important state in frxETHMinter and withdraw fund from frcETHMinter.

`admin` have privileges: `admin` can set address to mint any amount of frxETH, can set any address as `validator`, and change important state in `frxETHMinter` and withdraw fund from `frcETHMinter`

note the modifier below, either the `timelock governance contract` or the `contract owner` can access to all the high privilege function.


```solidity

    modifier onlyByOwnGov() {
        require(msg.sender == timelock_address || msg.sender == owner, "Not owner or timelock");
        _;
    }
```

There are numerous methods that the `admin` could apply to rug pull the protocol and take all `user` funds.

the admin can;

1. add or remove validator from OperatorRegistry.sol

2. set minter address or remove minter address in frxETH.sol

3. minter set by admin can mint or burn any amount of frxETH token.

4. set ETE deduction ratio, withdraw any amount of ETH or ERC20 token in frcETHMinter.sol

## What went wrong and how to fix it next time.
* Didn`t think Of this to be honest.

# Take aways.

* Mitigation of this issue -> Without significant redesign it is not possible to avoid the admin being able to rug pull the protocol.

As a result the recommendation is to set all `admin` functions behind either a `timelocked DAO` or at least a `timelocked multisig contract`.

### [M-2] (https://github.com/code-423n4/2022-09-frax-findings/issues/110) Rewards delay release could cause yields steal and loss.

In the current rewards accounting, vault shares in `deposit()` and `redeem()` can not correctly record the spot yields generated by the staked asset. Yields are released over the next rewards cycle. As a result, `malicious users` can steal yields from `innocent users` by picking special timing to `deposit()` and `redeem()`.

In `syncRewards()`, the current asset balance is break into 2 parts: `storedTotalAssets` and `lastRewardAmount/nextRewards`. The lastRewardAmount is the surplus balance of the asset, or the most recent yields.

```solidity
// lib/ERC4626/src/xERC4626.sol
    function syncRewards() public virtual {
        // ...

        uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;

        storedTotalAssets = storedTotalAssets_ + lastRewardAmount_;

        uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;

        lastRewardAmount = nextRewards.safeCastTo192();
        // ...        
        rewardsCycleEnd = end;
    }

```

And in the next rewards cycle, `lastRewardAmount` will be linearly added to storedTotalAssets, their sum is the return value of totalAssets():



```solidity

    function totalAssets() public view override returns (uint256) {
        // ...

        if (block.timestamp >= rewardsCycleEnd_) {
            // no rewards or rewards fully unlocked
            // entire reward amount is available
            return storedTotalAssets_ + lastRewardAmount_;
        }

        // rewards not fully unlocked
        // add unlocked rewards to stored total
        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);
        return storedTotalAssets_ + unlockedRewards;
    }
```


`totalAssets()` will be referred when `deposit()` and `redeem()`.



```solidity

// lib/solmate/src/mixins/ERC4626.sol

    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {
        require((shares = previewDeposit(assets)) != 0, "ZERO_SHARES");
        // ...
        _mint(receiver, shares);
        // ...
    }

    function redeem() public virtual returns (uint256 assets) {
        // ...
        require((assets = previewRedeem(shares)) != 0, "ZERO_ASSETS");

        beforeWithdraw(assets, shares);

        _burn(owner, shares);

        // ...

        asset.safeTransfer(receiver, assets);
    }

    function previewDeposit(uint256 assets) public view virtual returns (uint256) {
        return convertToShares(assets);
    }

    function previewRedeem(uint256 shares) public view virtual returns (uint256) {
        return convertToAssets(shares);
    }

    function convertToShares(uint256 assets) public view virtual returns (uint256) {
        uint256 supply = totalSupply; 

        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());
    }

    function convertToAssets(uint256 shares) public view virtual returns (uint256) {
        uint256 supply = totalSupply; 

        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);
    }


```

 Based on the above rules, there are 2 potential abuse cases:

1. If `withdraw` just after the `rewardsCycleEnd timestamp`, a `user` can not get the yields from last rewards cycle. Since the `totalAssets()` only contain `storedTotalAssets` but not the yields part. It takes 1 rewards cycle to linearly add to the `storedTotalAssets`.

Assume per 10,000 asset staking generate yields of 70 for 7 days, and the reward cycle is 1 day. A malicious user Alice can do the following:

* watch the mempool for `withdraw(10,000)` from account Bob, front run it with `syncRewards()`, so that the most recent yields of amount 70 from Bob will stay in the vault.
* Alice will also deposit a 10,000 to take as much shares as possible.
* after 1 rewards cycle of 1 day, `redeem()` to take the yields of 70.

Effectively steal the yields from `Bob`. The profit for Alice is not 70, because after 1 day, her own deposit also generates some yield, in this example this portion is 1. At the end, Alice steal yield of `amount 60`.

2. When the `Multisig Treasury` transfers new yields into the vault, the new yields will accumulate until `syncRewards()` is called. It is possible that yields from multiple rewards cycles accumulates, and being released in the next cycle.

Knowing that the yields has been accumulated for 3 rewards cycles, a `malicious user` can `deposit()` and call `syncRewards()` to trigger the release of the rewards. `redeem()` after 1 cycle.

Here the malicious user gets yields of 3 cycles, lose 1 in the waiting cycle. The net profit is 2 cycle yields, and the gained yields should belong to the other `users` in the vault.


## What went wrong and how to fix it next time.
* Didn`t think Of this to be honest.


# Take aways.

* When dealing with rewards distribution when any delays have been used like cycles being compared with present time(`block.timestamp`) look for ways in which a malicious user can frontrun any tx that includes innocent users withdrawing their staked yields and see whether you can grief them with less or no yields.
* Mitigation of this issue -> or the `lastRewardAmount` not released, allow the users to redeem as it is linearly released later.

### [M-3](https://github.com/code-423n4/2022-09-frax-findings/issues/113) frxETH can be depegged due to the ETH staking balance slashing.

The main risk in ETH 2.0 POS staking is the slashing penalty, in that case the frxETH will not be pegged and the validator cannot maintain a minimum 32 ETH staking balance.

## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest.


# Take aways.

* Always check to see whether a token can become depegged when the slashing penalty occurs.


### [M-04](https://github.com/code-423n4/2022-09-frax-findings/issues/12) removeValidator() & removeMinter() may fail due to exceeding gas limit.

`removeValidator()` and `removeMinter()` may fail due to exceeding gas limit.

```solidity
for (uint256 i = 0; i < original_validators.length; ++i) {

                if (i != remove_idx) {

                    validators.push(original_validators[i]);

                }

            }
```


```solidity
for (uint i = 0; i < minters_array.length; i++){ 

            if (minters_array[i] == minter_address) {

                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same

                break;

            }

        }

```

The `removeValidator` is used to remove a validator from the array `validators`.

There is an unbounded loop in `removeValidator()` such that if the `validators` array gets sufficiently large, this function call will fail due to exceeding the gas limit.

The same issue exists in the `removeMinter()` function. If `minters_array` gets large, the function call will fail.

## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest.
  
# Take aways.

* Always pay attention to unbounded loops and see if it can be manipulated by anyone apart from the admin.


### [M-5](https://github.com/code-423n4/2022-09-frax-findings/issues/17) frxETHMinter.depositEther may run out of gas, leading to lost ETH.

`frxETHMinter.depositEther` always iterates over all deposits that are possible with the current balance `((address(this).balance - currentWithheldETH) / DEPOSIT_SIZE)`. However, when a lot of ETH was deposited into the contract / it was not called in a long time, this loop can reach the gas limit. When this happens, no more calls to `depositEther` are possible, as it will always run out of gas.

Of course, the probability that such a situation arises depends on the price of ETH. For >1,000 USD it would need require someone to deposit a large amount of money (which can also happen, there are whales with thousands of ETH, so if one of them would decide to use frxETH, the problem can arise). For lower prices, it can happen even for small (in dollar terms) deposits. And in general, the correct functionality of a protocol should not depend on the price of ETH.


## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest.

# Take aways.

* Alwways remember when you are depositing ether through a function and there is a loop that deals compares what you have deposited to a another variable. think about how one cna inflate the number of deposits to cause a DOS attack.


### [M-6] (https://github.com/code-423n4/2022-09-frax-findings/issues/18) Non-conforming ERC20 tokens not recoverable.

There is a function `recoverERC20` to rescue any ERC20 tokens that were accidentally sent to the contract. However, there are tokens that do not return a value on success, which will cause the call to revert, even when the transfer would have been successful. This means that those tokens will be stuck forever and not recoverable.

## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest.


# Take aways.

* Everytime I see a function handling a ERC20 token always think of weird erc20s.

### [M-7] (https://github.com/code-423n4/2022-09-frax-findings/issues/219) `getNextValidator` error could temporarily make `depositEther` inoperable.

When `depositEther()`, if `1 validator` is used before, the whole `deposit` function will revert, causing DoS. `depositEther()` function will be inoperable until the gov manually remove the mistaken `validator`.

In `depositEther()`, if the `pubKey` is already used, the whole loop will revert, and the `deposit` operation cannot move on.

```solidity

// src/frxETHMinter.sol
    function depositEther() external nonReentrant {
        // ...

        for (uint256 i = 0; i < numDeposits; ++i) {
            // Get validator information
            (
                bytes memory pubKey,
                bytes memory withdrawalCredential,
                bytes memory signature,
                bytes32 depositDataRoot
            ) = getNextValidator(); // Will revert if there are not enough free validators

            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth
            // until withdrawals are allowed
            require(!activeValidators[pubKey], "Validator already has 32 ETH");
        // ...        
    }

```

And in the next rewards cycle, lastRewardAmount will be linearly added to storedTotalAssets, their sum is the return value of `totalAssets()`:

```solidity

    function totalAssets() public view override returns (uint256) {
        // ...

        if (block.timestamp >= rewardsCycleEnd_) {
            // no rewards or rewards fully unlocked
            // entire reward amount is available
            return storedTotalAssets_ + lastRewardAmount_;
        }

        // rewards not fully unlocked
        // add unlocked rewards to stored total
        uint256 unlockedRewards = (lastRewardAmount_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);
        return storedTotalAssets_ + unlockedRewards;
    }

```


Temporarily the `depositEther()` function will be inaccessible. Until the governance calls the registry to pop the wrong validator.

```solidity
// src/OperatorRegistry.sol
    function popValidators(uint256 times) public onlyByOwnGov {
        // Loop through and remove validator entries at the end
        for (uint256 i = 0; i < times; ++i) {
            validators.pop();
        }

        emit ValidatorsPopped(times);
    }
```

## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest.


# Take aways.

* In any function, if any filed or variable can be used more than once which suppose to not be the case try and see whether that function has a try and catch function that handles that unexpected scenario.


### [M-8] (https://github.com/code-423n4/2022-09-frax-findings/issues/221) Withheld ETH should not be sent back to the frxETHMinter contract itself.

It will lead to duplicating accounting for the Eths which have been already converted to the frxETH tokens. It means Eth:frxEth will not be 1:1, and eventually leads to decoupling.

The function `moveWithheldETH` will send the `amount` of the withheld ETH in the contract to the address `to`. It doesnt check if the `to` address is the `frxETHMinter` contract itself.

And the frxETHMinter has the `receive` function which will submit any `eth` received to the `frxETH`.


```solidity
/// @notice Fallback to minting frxETH to the sender
    receive() external payable {
        _submit(msg.sender);
    }

```

But these parts of Eths (WithheldETH) also have been converted to the `frxETH` normally when they were sent to the contract at the first time.

```solidity
    function _submit(address recipient) internal nonReentrant {
        // Initial pause and value checks
        ...
        // Give the sender frxETH
        frxETHToken.minter_mint(recipient, msg.value);

```

So these `Eths` will be accounted, Twice, even more. It means Eth:frxEth will not be 1:1 anymore.

The function recoverEther has the same problem. Although these two functions can only be called by owner or DAO gov. It seriously affects financial stability.

## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest because this was an admin function.

# Take aways.

* always look at scenarios whereby a token is minted without depositing new ETH through manipulation of the receive function.
* Pay attention to the `to` address everything transfers of ETH occurs.

### [M-9] (https://github.com/code-423n4/2022-09-frax-findings/issues/346) recoverEther not updating currentWithheldETH breaks calculation of withheld amount for furthur deposits.

The emergency exit function `recoverEther` allows the owner to retrieve the ETH in case an issue were to happen.

The problem is that this function does not update `currentWithheldETH`.

This means upon deposit starting again after the emergency recovery, `currentWithheldETH` will have an offset and will not match the withholdRatio.

Direct consequences:

* depositEther may not deposit the expected amount of ETH into the ETH 2.0 staking contract.
* the amount of ETH moved to an external yield protocol using moveWithheldETH() will be higher than what it should be.


* frxETHMinter has a withholdRatio set to 2 * 1e5 - ie the contract is meant to hold 20% of the ETH deposited.
* users deposit ETH into the contract.
* An issue happens and the owner calls recoverEther(address(this).balance). Before the call, the total balance was 1e20 (100 ETH), and currentWithheldETH == 2 * 1e19 - for simplicity we assume no calls to moveWithheldETH or depositEther have been done yet.
* The ETH balance of the minter is now 0, but currentWithheldETH is still 2 * 1e19
* Users start depositing again.
* At this point, the total balance is now `1e20` (100 ETH), and `currentWithheldETH == 4 * e19`
* The owner calling `depositEther` deposits `32 ether` instead of `64 ether`, because `currentWithheldETH == 40 ether` instead of `20 ether`. The owner can also call moveWithheldETH with `amount == 4 * 1e19` instead of `amount == 2 * 1e19`.


## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest.
* Had no edge case thinking.


# Take aways.

* Make sure when I am removing or adding something always pay attention to the variables that are being updated.

### [M-10] (https://github.com/code-423n4/2022-09-frax-findings/issues/35) The volatile result of previewMint() may prevent mintWithSignature from working.

In `sfrxETH` contracts, the result of `previewMint()` changes with the state of the contract, which causes the value of amount to be volatile in the `mintWithSignature` function when `approveMax` is false.
And when using the `mintWithSignature` function, which requires the user to sign for an accurate amount value, when the amount used differs from the result of `previewMint()`, `mintWithSignature` will not work.
Consider the following scenarios.
* User A signs using amount = 1000 and calls the mintWithSignature function.
* During execution, the previous transaction in the same block changes the state of the contract so that previewMint(shares) == 1001, so the transaction is reverted due to a signature check failure.

## What went wrong and how to fix it next time.

* Didn`t think Of this to be honest.
* Limited knowledge on signatures.

# Take aways.

* Provide a max amount and compare it to avoid DOS, and use maxAmount to verify the signature.