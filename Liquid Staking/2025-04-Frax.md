# Summary.

A liquid ETH staking derivative designed to uniquely leverage the Frax Finance ecosystem.

### Findings.

### [H-1](https://github.com/code-423n4/2022-09-frax-findings/issues/15) Wrong accounting logic when syncRewards() is called within beforewithdraw makes withdrawals impossible.

The `sfrx.beforewithdraw` first calls the `beforeWithdraw` of `xERC4626`, which decrements `storedTotalAssets` by the given amount.
When,
`(block.timestamp >= rewardsCycleEnd)`, `syncRewards` is called. However, the problem is that the assets have not been transferred out yet, meaning `asset.balanceOf(address(this))` still has the old value. On the other hand, **`storedTotalAssets`** was already updated. Therefore, the following calculation will be inflated by the amount for which the withdrawal was requested:

```solidity
uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;
```

This has severe consequences:
1.) During the following reward period, lastRewardAmount is too high, which means that too much rewards are paid out too users who want to withdraw. A user could exploit this to steal the assets of other users.
2.) When `syncRewards()` is called the next time, it is possible that the nextRewards calculation underflows because `lastRewardAmount > asset.balanceOf(address(this))`. This is very bad because `syncRewards()` will be called in every withdrawal (after the rewardsCycleEnd) and none of them will succeed because of the underflow. Depositing more also does not help here, it just increases asset.balanceOf(address(this)) and storedTotalAssets by the same amount, which does not eliminate the underflow.

## What went wrong and how to fix it next time.
* Didn`t think about this edge-case.
* Again didnt review the whole codebase.

## Take aways.

* When withdrawing from a vault contract take a keen look on what is going on with the variables that are responsible for the withdraw method i.e check for instances of overflows and underflows and make sure their updates are in sync with each other. (Would consider using fuzz).


## Findings.